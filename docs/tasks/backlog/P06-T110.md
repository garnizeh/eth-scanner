# P06-T110: Write benchmarks for key scanning throughput

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Not Started  
**Priority:** Medium  
**Dependencies:** P06-T040  
**Estimated Effort:** Small (< 1h)

---

## Description

Create comprehensive benchmarks for the key scanning pipeline to measure throughput (keys/sec) and track performance over time. Benchmarks should cover individual functions (`ConstructPrivateKey`, `DeriveEthereumAddress`) as well as the full scanning loop (`ScanRange`, `ScanRangeParallel`).

---

## Acceptance Criteria

- [ ] Benchmark `BenchmarkConstructPrivateKey` measures key construction speed
- [ ] Benchmark `BenchmarkDeriveEthereumAddress` measures address derivation speed
- [ ] Benchmark `BenchmarkScanRange` measures single-threaded scanning throughput
- [ ] Benchmark `BenchmarkScanRangeParallel` measures multi-threaded scanning throughput
- [ ] Benchmarks report allocations per operation (`-benchmem`)
- [ ] README or docs document expected throughput on reference hardware
- [ ] CI runs benchmarks and checks for regressions (optional)

---

## Implementation Notes

**Key Points:**
- Reference SDD section: 4.3.7 (Performance Measurement)
- Use `testing.B` for benchmarks
- Run with: `go test -bench=. -benchmem ./internal/worker`
- Report throughput in keys/sec: `b.N / b.Elapsed().Seconds()`

**Benchmark Examples:**
```go
func BenchmarkConstructPrivateKey(b *testing.B) {
	prefix := [28]byte{0x01, 0x02, /* ... */}
	var nonce uint32 = 12345
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = ConstructPrivateKey(prefix, nonce)
	}
}

func BenchmarkDeriveEthereumAddress(b *testing.B) {
	key := [32]byte{0x01, 0x02, /* valid key */ }
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = DeriveEthereumAddress(key)
	}
}

func BenchmarkScanRange(b *testing.B) {
	job := Job{
		Prefix28:   [28]byte{/* ... */},
		NonceStart: 0,
		NonceEnd:   uint32(b.N),
	}
	targetAddr := common.HexToAddress("0x0000000000000000000000000000000000000000")
	ctx := context.Background()
	
	b.ResetTimer()
	_, _ = ScanRange(ctx, job, targetAddr)
	
	// Report throughput
	keysPerSec := float64(b.N) / b.Elapsed().Seconds()
	b.ReportMetric(keysPerSec, "keys/sec")
}

func BenchmarkScanRangeParallel(b *testing.B) {
	job := Job{
		Prefix28:   [28]byte{/* ... */},
		NonceStart: 0,
		NonceEnd:   uint32(b.N),
	}
	targetAddr := common.HexToAddress("0x0000000000000000000000000000000000000000")
	ctx := context.Background()
	
	b.ResetTimer()
	_, _ = ScanRangeParallel(ctx, job, targetAddr)
	
	// Report throughput
	keysPerSec := float64(b.N) / b.Elapsed().Seconds()
	b.ReportMetric(keysPerSec, "keys/sec")
}
```

**Reference Hardware:**
- Document hardware specs in comments or README
- Example: "Intel i7-8700K: ~500,000 keys/sec (single-threaded), ~3,000,000 keys/sec (12 threads)"

---

## Testing

- Run benchmarks with `-benchmem` to verify zero allocations
- Run benchmarks with varying `b.N` to verify scaling
- Compare parallel vs single-threaded: speedup should match core count
- Add benchmark results to documentation

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.3.7)
- Go testing package: https://pkg.go.dev/testing
- Benchmark tutorial: https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go
- Related tasks: P06-T100 (optimizations measured by these benchmarks)
