# P06-T080: Implement checkpoint goroutine (periodic PATCH)

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P06-T070, P05-T040  
**Estimated Effort:** Medium (1-3h)

---

## Description

Implement a checkpoint goroutine that runs alongside the scanning workers and periodically (e.g., every 5 minutes) sends progress updates to the Master API via `PATCH /api/v1/jobs/{id}/checkpoint`. This ensures minimal work loss if the worker crashes or is terminated.

---

## Acceptance Criteria

- [ ] Checkpoint goroutine launched when batch processing starts
- [ ] Goroutine sends checkpoint every 5 minutes (configurable)
- [ ] Reads current nonce from atomic counter (P06-T070)
- [ ] Calls `UpdateCheckpoint()` from P05-T040 with current nonce and keys scanned
- [ ] Handles transient errors gracefully (log and retry on next interval)
- [ ] Stops cleanly when batch completes or context is cancelled
- [ ] Unit tests verify checkpoint timing and API calls

---

## Implementation Notes

**Key Points:**
- Reference SDD section: 4.4.3 (Checkpointing)
- Use `time.Ticker` for periodic execution (every 5 minutes)
- Calculate `keys_scanned` from (current_nonce - nonce_start)
- Handle API errors: log and continue (don't fail entire scan)
- Ensure final checkpoint is sent when batch completes (in addition to periodic)

**Code Pattern:**
```go
func (w *Worker) runCheckpointLoop(ctx context.Context, jobID int64, scanner *Scanner, startNonce uint32) {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()
	
	for {
		select {
		case <-ticker.C:
			currentNonce := scanner.GetCurrentNonce()
			keysScanned := currentNonce - uint64(startNonce)
			
			err := w.client.UpdateCheckpoint(ctx, jobID, uint32(currentNonce), keysScanned)
			if err != nil {
				// Log error but don't fail scan
				log.Printf("checkpoint update failed: %v", err)
			}
			
		case <-ctx.Done():
			// Send final checkpoint before exit
			currentNonce := scanner.GetCurrentNonce()
			keysScanned := currentNonce - uint64(startNonce)
			
			// Use background context for final checkpoint (don't fail on timeout)
			bgCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
			defer cancel()
			_ = w.client.UpdateCheckpoint(bgCtx, jobID, uint32(currentNonce), keysScanned)
			return
		}
	}
}
```

**Error Handling:**
- Network errors: retry on next interval (don't block scanning)
- 401 Unauthorized: log and abort worker (invalid credentials)
- 404 Job not found: abort worker (job was deleted/expired)

---

## Testing

- Unit test: checkpoint sent after 5-minute interval
- Unit test: checkpoint includes correct nonce and keys_scanned
- Unit test: context cancellation triggers final checkpoint
- Unit test: API error doesn't stop checkpoint loop
- Integration test: verify Master API receives checkpoint updates

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.4.3)
- Related tasks: P06-T070 (progress tracking), P05-T040 (API client)
