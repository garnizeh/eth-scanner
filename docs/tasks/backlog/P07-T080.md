# P07-T080: Implement startup benchmark using esp_timer_get_time()

**Phase:** P07 - ESP32 Worker - Core Infrastructure  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P07-T010  
**Estimated Effort:** Small

---

## Description

Implement a lightweight benchmark function using `esp_timer_get_time()` to measure key generation throughput at startup. This provides accurate keys/second measurement for dynamic batch size calculation.

## Acceptance Criteria

- [x] Benchmark function implemented with microsecond precision
- [x] Measures throughput for 10,000+ key generations
- [x] Calculates average keys/second
- [x] Result stored in global state for batch size calculator
- [x] Logged at startup for diagnostics
- [x] Uses minimal crypto implementation (secp256k1 + keccak256)

## Implementation Notes

**File:** `esp32/src/benchmark.c`

**Implementation:**
```c
#include "esp_timer.h"
#include "esp_log.h"
#include <string.h>

#define BENCHMARK_ITERATIONS 10000

static const char* TAG = "benchmark";

// Minimal crypto stubs for benchmarking (full impl in P08)
extern void derive_eth_address(const uint8_t* privkey, uint8_t* address);

uint32_t benchmark_key_generation(void)
{
    uint8_t privkey[32] = {0};
    uint8_t address[20];
    uint32_t nonce = 0;
    
    ESP_LOGI(TAG, "Starting benchmark (%d iterations)...", BENCHMARK_ITERATIONS);
    
    // Warm-up (exclude from measurement)
    for (int i = 0; i < 100; i++) {
        derive_eth_address(privkey, address);
    }
    
    // Benchmark loop
    int64_t start = esp_timer_get_time();  // microseconds
    
    for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {
        // Simulate nonce increment (last 4 bytes)
        memcpy(&privkey[28], &nonce, sizeof(nonce));
        derive_eth_address(privkey, address);
        nonce++;
    }
    
    int64_t end = esp_timer_get_time();
    int64_t elapsed_us = end - start;
    
    // Calculate keys per second
    double elapsed_sec = elapsed_us / 1000000.0;
    double keys_per_sec = BENCHMARK_ITERATIONS / elapsed_sec;
    
    ESP_LOGI(TAG, "Benchmark complete: %.2f keys/sec (%.2f ms total)", 
             keys_per_sec, elapsed_us / 1000.0);
    
    return (uint32_t)keys_per_sec;
}
```

**Integration in `app_main()`:**
```c
void app_main(void)
{
    // ... NVS, WiFi init ...
    
    ESP_LOGI(TAG, "Running startup benchmark...");
    uint32_t throughput = benchmark_key_generation();
    g_state.keys_per_second = throughput;
    
    ESP_LOGI(TAG, "Device throughput: %lu keys/sec", throughput);
    
    // Pass throughput to batch size calculator
    uint32_t batch_size = calculate_batch_size(throughput, 3600);  // 1 hour target
    ESP_LOGI(TAG, "Calculated batch size: %lu", batch_size);
    
    // ... Continue with worker tasks ...
}
```

**Expected throughput (ESP32 @ 240MHz):**
- Without hardware acceleration: ~50-100 keys/sec
- With optimized crypto: ~200-500 keys/sec
- Goals may vary based on crypto library and optimization level

**Benchmark considerations:**
- Run once at startup (cached result)
- Run again if frequency changes (menuconfig option)
- Exclude from production builds if batch size is pre-configured

## Testing

- Flash firmware and verify benchmark runs at startup
- Verify throughput value logged and reasonable (>0)
- Test with different CPU frequencies (160MHz vs 240MHz)
- Verify warm-up loop prevents initial cache misses from skewing results
- Compare results with real scanning loop throughput

## References

- SDD: `docs/architecture/system-design-document.md` (Dynamic Batching)
- ESP-IDF Timer: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html
- Related tasks: P07-T090 (batch size calculator uses this result)
