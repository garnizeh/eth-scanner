# P03-T080: Implement graceful shutdown with context.Context

**Phase:** P03 - Master API - Core Infrastructure  
**Status:** Not Started  
**Priority:** Medium  
**Dependencies:** P03-T060  
**Estimated Effort:** Small

---

## Description

Enhance the Master API server with robust graceful shutdown capabilities using `context.Context`. Ensure all in-flight requests complete, database connections close properly, and resources are cleaned up before the application exits.

## Acceptance Criteria

- [ ] Server uses `http.Server.Shutdown()` for graceful termination
- [ ] Context cancellation propagates to all goroutines
- [ ] In-flight HTTP requests are allowed to complete (with timeout)
- [ ] Database connections are closed before exit
- [ ] Shutdown timeout is configurable (default: 30 seconds)
- [ ] Shutdown process is logged with clear messages
- [ ] No goroutine leaks after shutdown

## Implementation Notes

**Server Shutdown Flow:**
```go
func (s *Server) Start(ctx context.Context) error {
    httpServer := &http.Server{
        Addr:    ":" + s.config.Port,
        Handler: s.router,
    }
    
    // Start server in goroutine
    serverErr := make(chan error, 1)
    go func() {
        serverErr <- httpServer.ListenAndServe()
    }()
    
    // Wait for context cancellation or server error
    select {
    case <-ctx.Done():
        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        log.Printf("Shutting down server...")
        if err := httpServer.Shutdown(shutdownCtx); err != nil {
            log.Printf("Server shutdown error: %v", err)
        }
        return ctx.Err()
    case err := <-serverErr:
        return err
    }
}
```

**Key Points:**

1. **Shutdown Timeout:**
   - Default: 30 seconds
   - Can be made configurable via `Config.ShutdownTimeout`
   - Use `context.WithTimeout()` for shutdown context

2. **Resource Cleanup:**
   - Database connections closed in `main()` via `defer db.Close()`
   - Any background goroutines should listen for context cancellation
   - Log each cleanup step

3. **In-Flight Requests:**
   - `http.Server.Shutdown()` waits for active connections
   - New requests rejected during shutdown
   - Long-running requests should respect context deadlines

4. **Error Handling:**
   - Log shutdown errors but don't panic
   - Return appropriate exit code from main

5. **Logging:**
   - Log shutdown initiation
   - Log timeout warnings if shutdown takes too long
   - Log successful completion

**Testing Scenarios:**
- Shutdown with no active requests
- Shutdown with active requests (should wait)
- Shutdown timeout (requests exceed timeout)
- Multiple shutdown signals

## Testing

```bash
cd /home/user/code/garnizeh/eth-scanner/go

# Test 1: Graceful shutdown with no traffic
./bin/master &
PID=$!
sleep 2
kill -SIGTERM $PID
wait $PID

# Test 2: Graceful shutdown with active request
./bin/master &
PID=$!
# Send long-running request in background
curl http://localhost:8080/health &
sleep 1
kill -SIGTERM $PID
# Server should wait for curl to complete
```

Manual verification:
- Server waits for in-flight requests
- Database connections closed cleanly
- No goroutine leaks (use `go test -race` if applicable)
- Logs show clean shutdown sequence

## References

- SDD: `docs/architecture/system-design-document.md`
- Copilot Instructions: Go Code Style - Context usage
- Go docs: `net/http.Server.Shutdown()`
- Related tasks: P03-T060 (main.go), P03-T070 (manual testing)
