# P05-T080: Implement worker main loop

**Phase:** P05 - PC Worker - Core Implementation  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P05-T030, P05-T050  
**Estimated Effort:** Medium

---

## Description

Implement the main worker loop that orchestrates the entire batch processing workflow: lease a job, scan the nonce range, submit checkpoints, complete the batch, and repeat. This is the core control flow of the PC worker.

## Acceptance Criteria

- [ ] `Run(ctx context.Context)` function exists in worker package
- [ ] Main loop implements the workflow:
  1. Calculate batch size based on throughput
  2. Lease a job from Master API
  3. Start scanning the nonce range (delegate to scanner - P06-T040)
  4. Periodically send checkpoints during scanning
  5. Complete the job when scanning finishes
  6. Repeat from step 1
- [ ] Context cancellation gracefully stops the loop
- [ ] Handles `ErrNoJobsAvailable` by waiting/retrying
- [ ] Handles lease expiration (stops scanning if lease expires)
- [ ] Logs progress and errors appropriately
- [ ] Graceful shutdown: completes current batch or saves checkpoint before exit

## Implementation Notes

### Main Loop Structure
```go
package worker

import (
    "context"
    "log"
    "time"
)

type Worker struct {
    client             *Client
    config             *Config
    measuredThroughput uint64
}

func NewWorker(config *Config) *Worker {
    return &Worker{
        client:             NewClient(config),
        config:             config,
        measuredThroughput: EstimateThroughput(), // from P05-T070
    }
}

func (w *Worker) Run(ctx context.Context) error {
    log.Println("Worker starting...")
    
    for {
        // Check if context is cancelled
        select {
        case <-ctx.Done():
            log.Println("Worker shutting down gracefully...")
            return ctx.Err()
        default:
        }
        
        // Step 1: Calculate batch size
        batchSize := CalculateBatchSize(w.measuredThroughput, 1*time.Hour)
        log.Printf("Requesting batch size: %d keys (~1 hour)", batchSize)
        
        // Step 2: Lease a job
        lease, err := w.client.LeaseBatch(ctx, batchSize)
        if err != nil {
            if err == ErrNoJobsAvailable {
                log.Println("No jobs available, waiting...")
                // Wait before retrying (handled in P05-T090)
                time.Sleep(30 * time.Second)
                continue
            }
            log.Printf("Failed to lease batch: %v", err)
            time.Sleep(10 * time.Second)
            continue
        }
        
        log.Printf("Leased job %s: nonce range [%d, %d]", lease.JobID, lease.NonceStart, lease.NonceEnd)
        
        // Step 3: Process the batch (scan nonce range)
        err = w.processBatch(ctx, lease)
        if err != nil {
            log.Printf("Batch processing failed: %v", err)
            // Continue to next iteration (job will expire and be reassigned)
            continue
        }
        
        log.Printf("Completed job %s", lease.JobID)
    }
}

func (w *Worker) processBatch(ctx context.Context, lease *JobLease) error {
    // Create a context with deadline matching lease expiration
    leaseCtx, cancel := context.WithDeadline(ctx, lease.ExpiresAt)
    defer cancel()
    
    // Track progress
    var (
        currentNonce uint64 = uint64(lease.NonceStart)
        totalKeys    uint64 = 0
    )
    
    // Start checkpoint goroutine
    checkpointTicker := time.NewTicker(w.config.CheckpointInterval)
    defer checkpointTicker.Stop()
    
    checkpointDone := make(chan struct{})
    go func() {
        defer close(checkpointDone)
        for {
            select {
            case <-leaseCtx.Done():
                return
            case <-checkpointTicker.C:
                // Send checkpoint
                err := w.client.UpdateCheckpoint(ctx, lease.JobID, uint32(currentNonce), totalKeys)
                if err != nil {
                    log.Printf("Checkpoint failed: %v", err)
                }
            }
        }
    }()
    
    // Scan the nonce range (implemented in P06-T040)
    // This is a placeholder - actual implementation in Phase 06
    log.Printf("Scanning nonce range [%d, %d]...", lease.NonceStart, lease.NonceEnd)
    
    // TODO P06-T040: Implement actual scanning
    // For now, simulate scanning with sleep
    select {
    case <-leaseCtx.Done():
        log.Println("Lease expired or context cancelled")
        return leaseCtx.Err()
    case <-time.After(5 * time.Second):
        // Simulate completion
        currentNonce = uint64(lease.NonceEnd)
        totalKeys = uint64(lease.NonceEnd - lease.NonceStart + 1)
    }
    
    // Wait for checkpoint goroutine to finish
    cancel()
    <-checkpointDone
    
    // Complete the batch
    err := w.client.CompleteBatch(ctx, lease.JobID, lease.NonceEnd, totalKeys)
    if err != nil {
        return fmt.Errorf("failed to complete batch: %w", err)
    }
    
    return nil
}
```

### Workflow Diagram
```
┌─────────────────────────────────────────────────┐
│ Worker Main Loop                                │
└─────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────┐
    │ Calculate    │
    │ Batch Size   │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │ Lease Job    │◄──────┐
    │ (API call)   │       │
    └──────┬───────┘       │
           │               │
           ▼               │
    ┌──────────────┐       │
    │ Scan Nonce   │       │ No jobs?
    │ Range        │       │ Retry
    └──────┬───────┘       │
           │               │
           ├──────────────►│
           │ (periodic     │
           │ checkpoints)  │
           │               │
           ▼               │
    ┌──────────────┐       │
    │ Complete Job │       │
    │ (API call)   │       │
    └──────┬───────┘       │
           │               │
           └───────────────┘
           (repeat)
```

### Context Handling
- **Parent context:** Passed to `Run()`, controls overall worker lifetime
- **Lease context:** Derived from parent with deadline = lease expiration
- **Checkpoint goroutine:** Uses lease context to stop when lease expires

### Graceful Shutdown
When context is cancelled:
1. Stop accepting new jobs
2. Cancel current batch scanning
3. Send final checkpoint (optional)
4. Exit cleanly

## Testing

```bash
cd /home/user/code/garnizeh/eth-scanner/go
go test ./internal/worker -v -run TestWorkerRun
```

### Test Cases
- Worker starts and leases a job successfully
- Worker processes batch and calls CompleteBatch
- Worker sends periodic checkpoints during scanning
- Context cancellation stops the worker gracefully
- `ErrNoJobsAvailable` triggers retry with delay
- Lease expiration cancels current batch
- Failed API calls are retried

### Integration Test
```go
func TestWorkerRun(t *testing.T) {
    // Create mock server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.URL.Path {
        case "/api/v1/jobs/lease":
            // Return mock job
            json.NewEncoder(w).Encode(leaseResponse{
                JobID:      "test-job-123",
                Prefix28:   strings.Repeat("00", 28),
                NonceStart: 0,
                NonceEnd:   1000,
                ExpiresAt:  time.Now().Add(10 * time.Minute).UTC().Format(time.RFC3339),
            })
        case "/api/v1/jobs/test-job-123/checkpoint":
            w.WriteHeader(http.StatusOK)
        case "/api/v1/jobs/test-job-123/complete":
            w.WriteHeader(http.StatusOK)
        }
    }))
    defer server.Close()
    
    // Create worker
    config := &Config{
        APIURL:             server.URL,
        WorkerID:           "test-worker",
        APIKey:             "test-key",
        CheckpointInterval: 1 * time.Second,
    }
    worker := NewWorker(config)
    
    // Run worker with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err := worker.Run(ctx)
    if err != context.DeadlineExceeded {
        t.Fatalf("expected deadline exceeded, got %v", err)
    }
}
```

## References

- SDD: `docs/architecture/system-design-document.md` (Section 3: Distributed Scanning Logic)
- Related tasks:
  - P05-T030 (LeaseBatch)
  - P05-T040 (UpdateCheckpoint)
  - P05-T050 (CompleteBatch)
  - P05-T070 (CalculateBatchSize)
  - P05-T090 (retry logic)
  - P06-T040 (actual scanning implementation)
