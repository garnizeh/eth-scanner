# P05-T090: Implement retry logic with exponential backoff

**Phase:** P05 - PC Worker - Core Implementation  
**Status:** Not Started  
**Priority:** Medium  
**Dependencies:** P05-T080  
**Estimated Effort:** Small

---

## Description

Implement robust retry logic with exponential backoff for the worker main loop to handle transient failures gracefully. This includes retrying when no jobs are available, handling network errors, and preventing tight retry loops that could overwhelm the Master API.

## Acceptance Criteria

- [ ] `Backoff` struct or helper function for managing retry delays
- [ ] Exponential backoff algorithm: delay doubles after each failure (e.g., 1s, 2s, 4s, 8s, ...)
- [ ] Maximum backoff delay configurable (default: 5 minutes)
- [ ] Minimum backoff delay configurable (default: 1 second)
- [ ] Jitter added to prevent thundering herd (randomize delay ±25%)
- [ ] Backoff resets to minimum after successful operation
- [ ] Applied to:
  - No jobs available (`ErrNoJobsAvailable`)
  - Network errors during lease request
  - API errors (5xx server errors)
- [ ] Does NOT retry on client errors (4xx) - these are permanent failures

## Implementation Notes

### Backoff Implementation
```go
package worker

import (
    "math"
    "math/rand"
    "time"
)

type Backoff struct {
    minDelay time.Duration
    maxDelay time.Duration
    current  time.Duration
}

func NewBackoff(minDelay, maxDelay time.Duration) *Backoff {
    return &Backoff{
        minDelay: minDelay,
        maxDelay: maxDelay,
        current:  minDelay,
    }
}

// Next returns the next backoff duration with jitter and doubles the delay.
func (b *Backoff) Next() time.Duration {
    // Add jitter (±25%)
    jitter := float64(b.current) * 0.25 * (2*rand.Float64() - 1)
    delay := time.Duration(float64(b.current) + jitter)
    
    // Double the delay for next time
    b.current = b.current * 2
    if b.current > b.maxDelay {
        b.current = b.maxDelay
    }
    
    return delay
}

// Reset resets the backoff to minimum delay.
func (b *Backoff) Reset() {
    b.current = b.minDelay
}
```

### Integration with Main Loop
```go
func (w *Worker) Run(ctx context.Context) error {
    log.Println("Worker starting...")
    
    backoff := NewBackoff(1*time.Second, 5*time.Minute)
    
    for {
        select {
        case <-ctx.Done():
            log.Println("Worker shutting down gracefully...")
            return ctx.Err()
        default:
        }
        
        // Calculate batch size
        batchSize := CalculateBatchSize(w.measuredThroughput, 1*time.Hour)
        
        // Lease a job
        lease, err := w.client.LeaseBatch(ctx, batchSize)
        if err != nil {
            if err == ErrNoJobsAvailable {
                delay := backoff.Next()
                log.Printf("No jobs available, waiting %v...", delay)
                time.Sleep(delay)
                continue
            }
            
            // Check if it's a retryable error
            if isRetryable(err) {
                delay := backoff.Next()
                log.Printf("Lease failed (retryable): %v, waiting %v...", err, delay)
                time.Sleep(delay)
                continue
            }
            
            // Non-retryable error (e.g., 400 Bad Request)
            log.Printf("Lease failed (non-retryable): %v", err)
            return err
        }
        
        // Success - reset backoff
        backoff.Reset()
        
        log.Printf("Leased job %s: nonce range [%d, %d]", lease.JobID, lease.NonceStart, lease.NonceEnd)
        
        // Process the batch
        err = w.processBatch(ctx, lease)
        if err != nil {
            log.Printf("Batch processing failed: %v", err)
            // Don't backoff here - lease will expire and be reassigned
            continue
        }
        
        log.Printf("Completed job %s", lease.JobID)
    }
}

// isRetryable determines if an error is worth retrying.
func isRetryable(err error) bool {
    // Check if it's an API error
    apiErr, ok := err.(*APIError)
    if !ok {
        // Network errors are retryable
        return true
    }
    
    // 5xx server errors are retryable
    if apiErr.StatusCode >= 500 && apiErr.StatusCode < 600 {
        return true
    }
    
    // 429 Too Many Requests is retryable
    if apiErr.StatusCode == 429 {
        return true
    }
    
    // 4xx client errors are NOT retryable (except 429)
    return false
}
```

### Backoff Sequence Example
```
Attempt 1: Error → Wait 1s   (± 0.25s jitter)
Attempt 2: Error → Wait 2s   (± 0.5s jitter)
Attempt 3: Error → Wait 4s   (± 1s jitter)
Attempt 4: Error → Wait 8s   (± 2s jitter)
Attempt 5: Error → Wait 16s  (± 4s jitter)
Attempt 6: Error → Wait 32s  (± 8s jitter)
Attempt 7: Error → Wait 64s  (± 16s jitter)
Attempt 8: Error → Wait 128s (± 32s jitter)
Attempt 9: Error → Wait 256s (± 64s jitter) → capped at 300s (5 min)
Attempt 10: Success → Reset to 1s
```

### Jitter Explanation
Jitter prevents the "thundering herd" problem when multiple workers retry simultaneously (e.g., after Master API restart). By randomizing the delay by ±25%, workers spread out their retry attempts.

Example:
- Worker A: 4s + jitter = 3.2s
- Worker B: 4s + jitter = 4.8s
- Worker C: 4s + jitter = 3.5s

### Configuration
Make backoff parameters configurable in `Config`:
```go
type Config struct {
    // ... existing fields ...
    RetryMinDelay time.Duration // default: 1s
    RetryMaxDelay time.Duration // default: 5m
}
```

## Testing

```bash
cd /home/user/code/garnizeh/eth-scanner/go
go test ./internal/worker -v -run TestBackoff
```

### Test Cases
- Initial delay is minimum (1s)
- Delay doubles after each `Next()` call
- Delay is capped at maximum (5m)
- Jitter is applied (delay varies by ±25%)
- `Reset()` returns delay to minimum
- `isRetryable()` returns true for 5xx errors
- `isRetryable()` returns false for 4xx errors (except 429)
- `isRetryable()` returns true for network errors
- Worker retries on `ErrNoJobsAvailable` with backoff
- Worker resets backoff after successful lease

### Example Test
```go
func TestBackoff(t *testing.T) {
    b := NewBackoff(1*time.Second, 10*time.Second)
    
    // First delay
    delay1 := b.Next()
    if delay1 < 750*time.Millisecond || delay1 > 1250*time.Millisecond {
        t.Errorf("expected ~1s (±25%%), got %v", delay1)
    }
    
    // Second delay (should be ~2s)
    delay2 := b.Next()
    if delay2 < 1500*time.Millisecond || delay2 > 2500*time.Millisecond {
        t.Errorf("expected ~2s (±25%%), got %v", delay2)
    }
    
    // Fourth delay (should be ~8s)
    b.Next() // 4s
    delay4 := b.Next()
    if delay4 < 6*time.Second || delay4 > 10*time.Second {
        t.Errorf("expected ~8s (±25%%), got %v", delay4)
    }
    
    // Should cap at maxDelay
    for i := 0; i < 10; i++ {
        b.Next()
    }
    delayCapped := b.Next()
    if delayCapped > 12500*time.Millisecond { // 10s + 25%
        t.Errorf("expected max 10s (±25%%), got %v", delayCapped)
    }
    
    // Reset
    b.Reset()
    delayReset := b.Next()
    if delayReset < 750*time.Millisecond || delayReset > 1250*time.Millisecond {
        t.Errorf("expected ~1s after reset, got %v", delayReset)
    }
}

func TestIsRetryable(t *testing.T) {
    tests := []struct {
        name     string
        err      error
        expected bool
    }{
        {"500 Internal Server Error", &APIError{StatusCode: 500}, true},
        {"503 Service Unavailable", &APIError{StatusCode: 503}, true},
        {"429 Too Many Requests", &APIError{StatusCode: 429}, true},
        {"400 Bad Request", &APIError{StatusCode: 400}, false},
        {"404 Not Found", &APIError{StatusCode: 404}, false},
        {"Network error", fmt.Errorf("dial tcp: connection refused"), true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := isRetryable(tt.err)
            if result != tt.expected {
                t.Errorf("expected %v, got %v", tt.expected, result)
            }
        })
    }
}
```

## References

- SDD: `docs/architecture/system-design-document.md` (Section 3.3: Lease System)
- Related tasks: P05-T080 (main loop), P05-T030 (LeaseBatch)
- Go stdlib: `math/rand` for jitter
- Pattern: Exponential backoff with jitter (AWS best practices)
