# P06-T060: Implement nonce range partitioning across workers

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P06-T050  
**Estimated Effort:** Small (< 1h)

---

## Description

Extract and refine the nonce range partitioning logic into a separate, testable function `PartitionNonceRange()`. This ensures fair distribution of work across workers and handles edge cases (remainder assignment, single-worker case, very small ranges).

---

## Acceptance Criteria

- [ ] Function `PartitionNonceRange(start, end uint32, numWorkers int) []NonceRange` implemented
- [ ] Function returns slice of `NonceRange` structs (one per worker)
- [ ] Partitions are contiguous and cover the full range exactly
- [ ] Last worker receives remainder if range doesn't divide evenly
- [ ] Handles edge case: numWorkers=1 (returns single partition)
- [ ] Handles edge case: range smaller than numWorkers (some workers get empty ranges or reduce worker count)
- [ ] Unit tests verify correct partitioning in all cases

---

## Implementation Notes

**Key Points:**
- Extract partitioning logic from `ScanRangeParallel()` for testability
- Ensure no nonce is scanned twice or skipped
- Performance: This is a one-time calculation per batch, not critical path

**Code Structure:**
```go
type NonceRange struct {
	Start uint32
	End   uint32
}

func PartitionNonceRange(start, end uint32, numWorkers int) []NonceRange {
	if numWorkers <= 0 {
		numWorkers = 1
	}
	
	totalNonces := uint64(end) - uint64(start) + 1
	if totalNonces == 0 {
		return nil
	}
	
	// If range smaller than workers, reduce worker count
	if totalNonces < uint64(numWorkers) {
		numWorkers = int(totalNonces)
	}
	
	noncesPerWorker := totalNonces / uint64(numWorkers)
	partitions := make([]NonceRange, numWorkers)
	
	for i := 0; i < numWorkers; i++ {
		partitions[i].Start = start + uint32(uint64(i)*noncesPerWorker)
		if i == numWorkers-1 {
			partitions[i].End = end // last worker takes remainder
		} else {
			partitions[i].End = partitions[i].Start + uint32(noncesPerWorker) - 1
		}
	}
	
	return partitions
}
```

---

## Testing

- Unit test: 100 nonces, 4 workers → verify partitions [0-24], [25-49], [50-74], [75-99]
- Unit test: 101 nonces, 4 workers → last worker gets extra (verify end=100)
- Unit test: 3 nonces, 4 workers → only 3 workers used
- Unit test: 1 nonce, 10 workers → only 1 worker
- Unit test: verify no gaps between partitions
- Unit test: verify sum of partition sizes equals total range

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.3.4)
- Related tasks: P06-T050 (uses this function)
