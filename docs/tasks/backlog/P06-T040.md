# P06-T040: Implement scanner.go with nonce range scanning

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P06-T030  
**Estimated Effort:** Medium (1-3h)

---

## Description

Create `internal/worker/scanner.go` and implement the core scanning logic that iterates over a nonce range, constructs private keys, derives addresses, and compares against target address(es). This is the foundational scanning function before parallelization.

---

## Acceptance Criteria

- [ ] File `go/internal/worker/scanner.go` created
- [ ] Function `ScanRange(ctx context.Context, job Job, targetAddr common.Address) (*ScanResult, error)` implemented
- [ ] Function iterates from `job.NonceStart` to `job.NonceEnd` (inclusive)
- [ ] For each nonce: construct key → derive address → compare with target
- [ ] Function respects `context.Context` cancellation (check periodically)
- [ ] Returns `ScanResult` with found key if match, or nil if no match
- [ ] Unit tests verify correct scanning behavior

---

## Implementation Notes

**Key Points:**
- Reference SDD section: 4.3.3 (Scanning Logic)
- Single-threaded scanner first; parallelization in P06-T050
- Context checking: check `ctx.Done()` every N iterations (e.g., every 10,000)
- Target address is provided by master (initial MVP: scan for one target)
- Return immediately if match found

**Code Structure:**
```go
type Job struct {
	ID          int64
	Prefix28    [28]byte
	NonceStart  uint32
	NonceEnd    uint32
	ExpiresAt   time.Time
}

type ScanResult struct {
	PrivateKey [32]byte
	Address    common.Address
	Nonce      uint32
}

func ScanRange(ctx context.Context, job Job, targetAddr common.Address) (*ScanResult, error) {
	for nonce := job.NonceStart; nonce <= job.NonceEnd; nonce++ {
		// Check context cancellation periodically
		if nonce%10000 == 0 {
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
		
		// Construct key and derive address
		key := ConstructPrivateKey(job.Prefix28, nonce)
		addr, err := DeriveEthereumAddress(key)
		if err != nil {
			continue // skip invalid keys
		}
		
		// Check for match
		if addr == targetAddr {
			return &ScanResult{
				PrivateKey: key,
				Address:    addr,
				Nonce:      nonce,
			}, nil
		}
	}
	
	return nil, nil // no match found
}
```

---

## Testing

- Unit test: scan small range (100 nonces), no match expected
- Unit test: scan range with known match at specific nonce
- Unit test: context cancellation stops scan mid-range
- Unit test: verify nonce_end is inclusive (scans last nonce)

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.3.3)
- Related tasks: P06-T050 (parallelizes this scanner), P06-T020, P06-T030
