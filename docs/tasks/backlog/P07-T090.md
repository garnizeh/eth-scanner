# P07-T090: Implement Batch Size Calculator (Keys/sec logic for 1-hour lease windows)

**Phase:** P07 - ESP32 Worker - Core Infrastructure  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P07-T080  
**Estimated Effort:** Small

---

## Description

Implement batch size calculation logic that determines optimal batch size based on measured throughput (keys/second) and target lease duration (default 1 hour). This ensures ESP32 requests appropriately-sized jobs from Master API.

## Acceptance Criteria

- [x] `calculate_batch_size()` function implemented
- [x] Takes throughput (keys/sec) and target duration (seconds) as input
- [x] Returns batch size clamped to reasonable min/max values
- [x] Accounts for checkpoint overhead (~5% reduction)
- [x] Handles edge cases (zero throughput, overflow)
- [x] Default target duration: 3600 seconds (1 hour)

## Implementation Notes

**File:** `esp32/src/batch_calculator.c`

**Implementation:**
```c
#include <stdint.h>
#include "esp_log.h"

#define MIN_BATCH_SIZE 10000        // Minimum 10K keys
#define MAX_BATCH_SIZE 10000000     // Maximum 10M keys (ESP32 limit)
#define CHECKPOINT_OVERHEAD 0.05    // 5% reduction for checkpoint time

static const char* TAG = "batch_calc";

uint32_t calculate_batch_size(uint32_t keys_per_second, uint32_t target_duration_sec)
{
    // Handle edge cases
    if (keys_per_second == 0) {
        ESP_LOGW(TAG, "Zero throughput, using minimum batch size");
        return MIN_BATCH_SIZE;
    }
    
    if (target_duration_sec == 0) {
        target_duration_sec = 3600;  // Default 1 hour
    }
    
    // Calculate raw batch size
    uint64_t raw_batch = (uint64_t)keys_per_second * target_duration_sec;
    
    // Apply checkpoint overhead reduction
    raw_batch = (uint64_t)(raw_batch * (1.0 - CHECKPOINT_OVERHEAD));
    
    // Clamp to min/max bounds
    uint32_t batch_size;
    if (raw_batch < MIN_BATCH_SIZE) {
        batch_size = MIN_BATCH_SIZE;
        ESP_LOGW(TAG, "Batch size too small, clamped to %lu", batch_size);
    } else if (raw_batch > MAX_BATCH_SIZE) {
        batch_size = MAX_BATCH_SIZE;
        ESP_LOGW(TAG, "Batch size too large, clamped to %lu", batch_size);
    } else {
        batch_size = (uint32_t)raw_batch;
    }
    
    ESP_LOGI(TAG, "Calculated batch size: %lu keys (%.2f hours @ %lu keys/sec)",
             batch_size, 
             (double)batch_size / keys_per_second / 3600.0,
             keys_per_second);
    
    return batch_size;
}
```

**Example calculations:**

| Keys/sec | Target (sec) | Raw Batch | After Overhead | Clamped Result |
|----------|--------------|-----------|----------------|----------------|
| 100      | 3600         | 360,000   | 342,000        | 342,000        |
| 500      | 3600         | 1,800,000 | 1,710,000      | 1,710,000      |
| 50       | 3600         | 180,000   | 171,000        | 171,000        |
| 10       | 3600         | 36,000    | 34,200         | 34,200         |
| 5000     | 3600         | 18,000,000| 17,100,000     | 10,000,000 (max)|

**Usage in worker loop:**
```c
// At startup
uint32_t throughput = benchmark_key_generation();
uint32_t batch_size = calculate_batch_size(throughput, 3600);

// When leasing job
job_info_t job;
esp_err_t err = api_lease_job(CONFIG_ETHSCANNER_WORKER_ID, batch_size, &job);
```

**Adaptive batch sizing (future enhancement):**
- Adjust target duration based on network stability
- Increase batch size for stable connections
- Decrease for unstable/high-latency connections

## Testing

- Test with various throughput values (10, 100, 500, 5000 keys/sec)
- Verify clamping to MIN_BATCH_SIZE when throughput very low
- Verify clamping to MAX_BATCH_SIZE when throughput very high
- Test with zero throughput (should return MIN_BATCH_SIZE)
- Test with various target durations (1800, 3600, 7200 seconds)
- Verify overhead reduction applied correctly

## References

- SDD: `docs/architecture/system-design-document.md` (Dynamic Batching)
- Related tasks: P07-T080 (benchmark provides throughput), P08-T050 (lease uses this batch size)
