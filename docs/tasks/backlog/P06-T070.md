# P06-T070: Implement atomic progress tracking

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P06-T060  
**Estimated Effort:** Medium (1-3h)

---

## Description

Implement thread-safe progress tracking using `atomic.Uint64` to track the current nonce being scanned across all worker goroutines. This allows the checkpoint goroutine (P06-T080) to safely read progress without locks, minimizing contention in the hot loop.

---

## Acceptance Criteria

- [ ] Global or scanner-local `atomic.Uint64` variable for tracking current nonce
- [ ] Each worker goroutine updates the atomic counter periodically (e.g., every 1000 nonces)
- [ ] Checkpoint reader can safely read current progress without blocking workers
- [ ] Unit tests verify atomic operations work correctly under concurrent access
- [ ] Benchmarks confirm minimal performance overhead (< 1% slowdown)

---

## Implementation Notes

**Key Points:**
- Reference SDD section: 4.3.5 (Progress Tracking)
- Use `sync/atomic.Uint64` (Go 1.19+) or `atomic.Uint64` type
- Update frequency: balance between accuracy and performance overhead
- Avoid updating atomic counter every iteration (too expensive)
- Suggested: update every 1,000-10,000 nonces

**Code Pattern:**
```go
type Scanner struct {
	currentNonce atomic.Uint64
	// ... other fields
}

func (s *Scanner) ScanRange(ctx context.Context, job Job, targetAddr common.Address) (*ScanResult, error) {
	for nonce := job.NonceStart; nonce <= job.NonceEnd; nonce++ {
		// Update progress periodically
		if nonce%1000 == 0 {
			s.currentNonce.Store(uint64(nonce))
		}
		
		// Check context periodically
		if nonce%10000 == 0 {
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
		
		// ... scanning logic
	}
	return nil, nil
}

func (s *Scanner) GetCurrentNonce() uint64 {
	return s.currentNonce.Load()
}
```

**Integration with ScanRangeParallel:**
- Each worker updates the same atomic counter
- The highest nonce value represents current progress
- Alternative: track per-worker progress and aggregate (more complex)

---

## Testing

- Unit test: single worker updates atomic counter correctly
- Unit test: multiple workers updating concurrently (verify no races)
- Unit test: checkpoint reader can read progress during scan
- Benchmark: compare scan performance with and without atomic updates
- Race detector: run tests with `-race` flag to verify safety

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.3.5)
- Go atomic package: https://pkg.go.dev/sync/atomic
- Related tasks: P06-T080 (checkpoint goroutine reads this value)
