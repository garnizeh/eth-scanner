# A01-T010: Worker-specific prefix affinity for nonce exhaustion

**Phase:** A01 - Performance & Optimization (Adhoc)  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** None  
**Estimated Effort:** Medium (1-3h)

---

## Description

Implement worker-specific prefix affinity so that when a worker completes a batch and requests a new lease, the master continues allocating nonce ranges from the same prefix (vertical exhaustion) instead of creating new random prefixes (horizontal fragmentation).

**Current Behavior (Problem):**
- Worker-1 requests batch → Master sends `prefix_28=0x0001...` and nonces `0-999999`
- Worker-2 requests batch → Master sends `prefix_28=0x9999...` and nonces `0-999999`
- Worker-1 completes batch and requests more → Master creates **new random prefix** `0xAAAA...` nonces `0-999999`
- Worker-2 completes batch and requests more → Master creates **new random prefix** `0xBBBB...` nonces `0-999999`

**Result:** Only nonces 0-999999 are explored across many prefixes. The 4-byte nonce space (2^32 = 4,294,967,296 keys) is underutilized.

**Desired Behavior:**
- Worker-1 requests batch → Master sends `prefix_28=0x0001...` and nonces `0-999999`
- Worker-2 requests batch → Master sends `prefix_28=0x9999...` and nonces `0-999999`
- Worker-1 completes batch and requests more → Master sends **same prefix** `0x0001...` and nonces `1000000-1999999`
- Worker-2 completes batch and requests more → Master sends **same prefix** `0x9999...` and nonces `1000000-1999999`

**Result:** Each worker exhausts the full 4-byte nonce space for its assigned prefix before the master assigns a new prefix.

---

## Acceptance Criteria

- [ ] Master tracks the last prefix assigned to each `worker_id` (e.g., in `workers` table or in-memory cache)
- [ ] When a worker requests a lease, the master checks if that worker has an incomplete prefix
- [ ] If the worker has an incomplete prefix (highest `nonce_end` < 2^32-1), the master allocates the next nonce range from that prefix
- [ ] If the worker's prefix is exhausted (all nonces up to 2^32-1 are allocated/completed), the master assigns a new prefix
- [ ] New workers (first lease) or workers without assigned prefix get a new random prefix or reuse a pending prefix with available space
- [ ] Unit tests verify sequential nonce allocation for the same worker across multiple leases
- [ ] Integration test confirms multiple workers exhaust their assigned prefixes independently

---

## Implementation Notes

**Key Points:**
- Reference SDD section: "Key Space Partitioning Logic" and "Dynamic Batching Strategy"
- Modify `internal/jobs/manager.go` and/or `internal/server/jobs.go` to implement prefix affinity
- Consider two approaches:
  1. **Database-backed:** Query `jobs` table for the last prefix assigned to `worker_id` (JOIN on `worker_id` and `MAX(nonce_end)`)
  2. **In-memory cache:** Store `worker_id → prefix_28` mapping (ephemeral, lost on restart but simpler)
- Preferred approach: **Database-backed** for persistence and correctness across master restarts
- Add SQL query (sqlc): `GetWorkerLastPrefix(worker_id) → (prefix_28, highest_nonce_end)`
- Modify `createAndLeaseBatch` to:
  1. Check if `worker_id` has an incomplete prefix
  2. If yes, use that prefix; otherwise, create/assign a new one
  3. Call `GetNextNonceRange(ctx, prefix28, batchSize)` with the selected prefix

**Proposed SQL Query (add to `internal/database/sql/queries.sql`):**
```sql
-- name: GetWorkerLastPrefix :one
SELECT prefix_28, MAX(nonce_end) as highest_nonce
FROM jobs
WHERE worker_id = ?
GROUP BY prefix_28
ORDER BY MAX(nonce_end) DESC
LIMIT 1;
```

**Code modification outline (pseudo-code):**
```go
func (s *Server) createAndLeaseBatch(...) {
    var prefix28 []byte
    
    // Check if worker has an incomplete prefix
    lastPrefix, err := q.GetWorkerLastPrefix(ctx, workerID)
    if err == nil && lastPrefix.HighestNonce < math.MaxUint32 {
        // Reuse worker's existing prefix
        prefix28 = lastPrefix.Prefix28
    } else {
        // Assign new prefix (random or from pool)
        if prefixOpt != nil {
            prefix28 = decodePrefixFromRequest(prefixOpt)
        } else {
            prefix28 = generateRandomPrefix()
        }
    }
    
    // Create batch with selected prefix
    created, err := m.CreateBatch(ctx, prefix28, batchSize)
    // ... rest of function
}
```

**Trade-offs:**
- **Pro:** Vertical exhaustion maximizes nonce utilization per prefix
- **Pro:** Workers can work independently on different prefixes without coordination
- **Con:** Slightly more complex query logic (JOIN or subquery)
- **Con:** Workers "own" a prefix until exhausted (could delay prefix rotation if worker dies)

**Mitigation for "stuck" workers:**
- Implement lease expiration logic (already exists) to reclaim jobs from dead workers
- Add optional master-side "reassignment" if a worker is idle for too long

---

## Testing

**How to verify this task is complete:**

1. **Unit Test:** Test `GetWorkerLastPrefix` query
   ```bash
   go test ./internal/database/... -run TestGetWorkerLastPrefix -v
   ```

2. **Unit Test:** Test prefix affinity in `createAndLeaseBatch`
   ```bash
   go test ./internal/server/... -run TestJobLeaseWorkerAffinity -v
   ```

3. **Integration Test:** Start master + 2 workers, verify nonce progression
   ```bash
   # Terminal 1: Start master
   make run-master
   
   # Terminal 2: Start worker-1
   WORKER_ID=worker-1 make run-worker
   
   # Terminal 3: Start worker-2
   WORKER_ID=worker-2 make run-worker
   
   # Terminal 4: Query database after 2-3 lease cycles
   sqlite3 data/scanner.db "SELECT worker_id, prefix_28, nonce_start, nonce_end FROM jobs ORDER BY worker_id, nonce_start;"
   ```

4. **Expected Outcome:**
   - Worker-1 should have sequential nonce ranges for the same prefix: `[0, 999999]`, `[1000000, 1999999]`, ...
   - Worker-2 should have sequential nonce ranges for a different prefix: `[0, 999999]`, `[1000000, 1999999]`, ...
   - No gaps or overlaps in nonce ranges per prefix

---

## References

- **SDD:** `docs/architecture/system-design-document.md` (Section "Key Space Partitioning Logic")
- **Schema:** `docs/database/schema.sql` (`jobs` table)
- **Current Code:** `internal/server/jobs.go` (`createAndLeaseBatch`)
- **Manager:** `internal/jobs/manager.go` (`GetNextNonceRange`, `CreateBatch`)
- **Related Tasks:** P04-T030 (nonce range allocation), P04-T050 (lease handler)

---

## Progress Log

### 2026-02-16 - Investigation
- Identified root cause: `createAndLeaseBatch` generates new random prefix when no pending jobs exist
- Current behavior: horizontal fragmentation (many prefixes, shallow nonce exploration)
- Proposed fix: worker-specific prefix affinity (vertical exhaustion)
- Approved approach: database-backed prefix tracking per `worker_id`

---

## Notes

**Why this matters:**
- Without vertical exhaustion, the brute-force engine only explores the first ~1 million nonces across thousands of prefixes
- With vertical exhaustion, each worker explores the full 4-byte nonce space (4.3 billion keys) per prefix
- This is critical for demonstrating the computational infeasibility of brute-forcing (educational goal)

**Future optimization:**
- Add a "prefix pool" table to pre-generate prefixes and assign them round-robin
- Implement load balancing: if a worker's prefix is >90% complete, assign a new prefix early to maintain steady throughput
