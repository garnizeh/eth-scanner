# P02-T070: Implement database migration versioning using goose library

**Phase:** P02 - Database Layer Implementation  
**Status:** Not Started  
**Priority:** Low (Optional for MVP)  
**Dependencies:** P02-T060  
**Estimated Effort:** Medium

---

## Description

Integrate the `pressly/goose` library for proper database migration versioning. This is optional for MVP but provides a production-ready migration strategy for future schema changes.

The schema file `001_schema.sql` already includes goose markers (`-- +goose Up/Down`), so this task adds the runtime integration to apply and manage migrations.

---

## Acceptance Criteria

- [ ] Add `github.com/pressly/goose/v3` to go.mod
- [ ] Verify goose works with `modernc.org/sqlite` (no CGO)
- [ ] Update `ApplySchema()` to use goose.Up() instead of manual execution
- [ ] Create `RunMigrations(ctx context.Context, db *sql.DB) error` function
- [ ] Add migration status check function
- [ ] Update Makefile with `make migrate-up` and `make migrate-status` targets
- [ ] Test migration up/down/status commands
- [ ] Document migration workflow in README

---

## Implementation Notes

```go
package database

import (
    "context"
    "database/sql"
    "embed"
    "fmt"
    
    "github.com/pressly/goose/v3"
)

//go:embed sql/*.sql
var embedMigrations embed.FS

// RunMigrations applies all pending migrations using goose
func RunMigrations(ctx context.Context, db *sql.DB) error {
    goose.SetBaseFS(embedMigrations)
    
    if err := goose.SetDialect("sqlite3"); err != nil {
        return fmt.Errorf("failed to set goose dialect: %w", err)
    }
    
    if err := goose.UpContext(ctx, db, "sql"); err != nil {
        return fmt.Errorf("failed to run migrations: %w", err)
    }
    
    return nil
}

// GetMigrationStatus returns current migration version
func GetMigrationStatus(ctx context.Context, db *sql.DB) (int64, error) {
    if err := goose.SetDialect("sqlite3"); err != nil {
        return 0, err
    }
    
    version, err := goose.GetDBVersionContext(ctx, db)
    if err != nil {
        return 0, fmt.Errorf("failed to get migration version: %w", err)
    }
    
    return version, nil
}
```

**Update InitDBWithSchema:**
```go
func InitDBWithSchema(ctx context.Context, dbPath string) (*sql.DB, error) {
    db, err := InitDB(dbPath)
    if err != nil {
        return nil, err
    }
    
    // Use goose for migrations
    if err := RunMigrations(ctx, db); err != nil {
        db.Close()
        return nil, err
    }
    
    return db, nil
}
```

**Makefile additions:**
```makefile
# Database migrations
migrate-up:
	@echo "Running migrations..."
	@go run cmd/migrate/main.go up

migrate-status:
	@echo "Migration status:"
	@go run cmd/migrate/main.go status

migrate-down:
	@echo "Rolling back last migration..."
	@go run cmd/migrate/main.go down
```

**Optional CLI tool** (`cmd/migrate/main.go`):
```go
package main

import (
    "context"
    "flag"
    "log"
    "os"
    
    "your-project/internal/database"
)

func main() {
    ctx := context.Background()
    dbPath := flag.String("db", "eth-scanner.db", "Database path")
    flag.Parse()
    
    if len(os.Args) < 2 {
        log.Fatal("Usage: migrate [up|down|status]")
    }
    
    db, err := database.InitDB(*dbPath)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    cmd := os.Args[1]
    switch cmd {
    case "up":
        if err := database.RunMigrations(ctx, db); err != nil {
            log.Fatal(err)
        }
        log.Println("Migrations applied successfully")
        
    case "status":
        version, err := database.GetMigrationStatus(ctx, db)
        if err != nil {
            log.Fatal(err)
        }
        log.Printf("Current version: %d", version)
        
    default:
        log.Fatalf("Unknown command: %s", cmd)
    }
}
```

---

## Testing

```go
func TestGooseMigrations(t *testing.T) {
    ctx := context.Background()
    dbPath := "test_goose.db"
    defer os.Remove(dbPath)
    
    db, err := InitDB(dbPath)
    if err != nil {
        t.Fatal(err)
    }
    defer db.Close()
    
    // Apply migrations
    err = RunMigrations(ctx, db)
    if err != nil {
        t.Fatalf("Failed to run migrations: %v", err)
    }
    
    // Check version
    version, err := GetMigrationStatus(ctx, db)
    if err != nil {
        t.Fatal(err)
    }
    
    if version != 1 {
        t.Errorf("Expected version 1, got %d", version)
    }
}
```

---

## References

- Goose documentation: https://github.com/pressly/goose
- Schema file: `internal/database/sql/001_schema.sql`
- Related tasks: P02-T060
- Note: This is optional for MVP, prioritize P02-T080 (tests) first
