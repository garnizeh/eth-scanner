# P06-T100: Optimize crypto loop (buffer reuse, minimize allocations)

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Not Started  
**Priority:** Medium  
**Dependencies:** P06-T040  
**Estimated Effort:** Medium (1-3h)

---

## Description

Optimize the cryptographic hot loop to minimize heap allocations and maximize throughput. This includes buffer reuse, avoiding unnecessary copies, and profiling to identify bottlenecks. The goal is to achieve maximum keys/sec scanning rate on target hardware.

---

## Acceptance Criteria

- [ ] Profiling performed with `pprof` to identify allocation hotspots
- [ ] `ConstructPrivateKey()` confirmed to be allocation-free (benchmark with `-benchmem`)
- [ ] Address comparison optimized (avoid unnecessary conversions)
- [ ] Memory profile shows minimal allocations in scanning loop
- [ ] Benchmarks show throughput improvement (before/after measurements)
- [ ] Document optimization techniques in code comments

---

## Implementation Notes

**Key Points:**
- Reference SDD section: 4.3.6 (Performance Optimization)
- Use `go test -bench=. -benchmem` to measure allocations
- Use `go test -cpuprofile=cpu.prof` and `go tool pprof` to analyze CPU usage
- Critical path: `ConstructPrivateKey()` → `DeriveEthereumAddress()` → address comparison

**Optimization Techniques:**

1. **Zero Allocations in ConstructPrivateKey:**
   - Use fixed-size arrays `[32]byte` instead of slices
   - Avoid `append()` or `make()`

2. **Address Comparison:**
   - `common.Address` is `[20]byte`, compare directly: `addr == targetAddr`
   - Avoid string conversions or `bytes.Equal()`

3. **Error Handling:**
   - In hot loop, only check critical errors
   - Invalid keys are rare, handle them efficiently

4. **CPU Cache Optimization:**
   - Keep frequently accessed data close together
   - Avoid pointer chasing

**Benchmarking:**
```bash
# Before optimization
go test -bench=BenchmarkScanRange -benchmem ./internal/worker

# After optimization
go test -bench=BenchmarkScanRange -benchmem ./internal/worker

# CPU profiling
go test -bench=BenchmarkScanRange -cpuprofile=cpu.prof ./internal/worker
go tool pprof cpu.prof
```

---

## Testing

- Benchmark: scan 10,000 nonces, measure time and allocations
- Memory profile: verify minimal heap allocations
- CPU profile: identify hottest functions
- Comparison test: verify optimization doesn't change correctness
- Document throughput numbers in comments (e.g., "500,000 keys/sec on Intel i7")

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.3.6)
- Go profiling guide: https://go.dev/blog/pprof
- High-performance Go: https://dave.cheney.net/high-performance-go-workshop/gopherchina-2019.html
- Related tasks: P06-T110 (benchmarks use these optimizations)
