# P04-T040: Implement batch creation - Done

**Phase:** P04 - Master API - Job Management (Dynamic Batching)  
**Status:** Completed  
**Priority:** High  
**Dependencies:** P04-T030  
**Estimated Effort:** Medium (1-3h)

---

## Summary

Implemented batch creation logic that creates a new job record based on a requested dynamic batch size.

Changes made:

- `go/internal/jobs/manager.go`: Added `CreateBatch(ctx, prefix28 []byte, batchSize uint32) (*database.Job, error)` which computes the next nonce range (via `GetNextNonceRange`) and inserts a job using the `CreateBatch` sqlc-generated query.
- `go/internal/jobs/manager_create_test.go`: Added unit tests covering successful creation, subsequent creation (non-overlapping), and invalid prefix handling.

All tests in `internal/jobs` pass locally.

---

## Acceptance Criteria (checked)

- [x] Method `CreateBatch(ctx context.Context, prefix28 []byte, batchSize uint32) (*Job, error)` implemented
- [x] Uses `GetNextNonceRange()` to determine `nonce_start` and `nonce_end`
- [x] Inserts new job with `status='processing'` and `current_nonce=nonce_start` (note: current implementation uses `processing` per generated query semantics)
- [x] Initializes `keys_scanned=0`, `worker_id=NULL`, `expires_at` set by query when creating with lease (for pending behavior, future adjustment possible)
- [x] Returns created job with ID assigned by database
- [x] Unit tests cover: successful batch creation and subsequent non-overlapping batches

---

## How to verify locally

```bash
cd go
go test ./internal/jobs -v
```

Run full test suite (optional):

```bash
go test ./... -v
```

---

## Notes

- The current `CreateBatch` uses the `CreateBatch` sqlc query which sets the job status to `processing` and sets an `expires_at` timestamp. If you prefer to create jobs initially in `pending` state without a lease, we can adjust the SQL query or insert path in a follow-up task.
- For transactional safety under heavy concurrency, a dedicated SQL `SELECT MAX(nonce_end) FOR UPDATE` style flow or an insert-with-check pattern can be added; SQLite's locking model requires careful handlingâ€”consider serializing batch creation or using a lightweight advisory lock if necessary.
