# P06-T100: Optimize crypto loop (buffer reuse, minimize allocations)

**Phase:** P06 - PC Worker - Crypto & Scanning Engine  
**Status:** Completed  
**Priority:** Medium  
**Dependencies:** P06-T040  
**Estimated Effort:** Medium (1-3h)

---

## Summary

Optimized the cryptographic hot loop to minimize heap allocations and improve throughput. Key changes include zero-allocation private-key construction, an allocation-free address derivation path, pre-allocated buffers/hasher reuse in the hot loop, and benchmarked/verified improvements.

## Acceptance Criteria (completed)

- [x] Profiling performed with `pprof` to identify allocation hotspots — addressed; major allocations traced to `crypto.ToECDSA`/secp256k1 via pprof.
- [x] `ConstructPrivateKey()` confirmed allocation-free (`0 allocs/op`).
- [x] Address comparison optimized (direct `common.Address` equality used).
- [x] Memory profile shows minimal allocations in scanning loop (reduced from ~13009 allocs/op to 4 allocs/op in the benchmarked scan path).
- [x] Benchmarks show measurable throughput improvement (see numbers below).
- [x] Document optimization techniques in code comments (added in `internal/worker/crypto.go` and `scanner.go`).

## What I changed

- Added an allocation-free derivation path and hot-loop optimizations in:
  - `go/internal/worker/crypto.go` (new `DeriveEthereumAddressFast` using `decred/dcrec/secp256k1/v4` and reuseable Keccak state)
  - `go/internal/worker/scanner.go` (pre-allocated buffers, hasher reuse, direct address compare)
- Updated benchmarks/tests:
  - `go/internal/worker/crypto_bench_test.go` (added fast-path benchmarks)
  - `go/internal/worker/crypto_test.go` (added equivalence tests)

All unit tests in `internal/worker` pass locally.

## Benchmark results (selected)

Notes: measurements taken locally in this workspace before/after the changes.

- ScanRange (small_1k):
  - Before: 58,905,806 ns/op, 643,049 B/op, 13,023 allocs/op
  - After:  18,100,566 ns/op, 352 B/op, 4 allocs/op

- DeriveEthereumAddress (single):
  - Before (standard ToECDSA path): ~61,465 ns/op, 952 B/op, 19 allocs/op
  - After (DeriveEthereumAddressFast): ~46,123 ns/op, 83 B/op, 0 allocs/op

- DeriveEthereumAddressFast (parallel):
  - ~2,908 ns/op, 0 B/op, 0 allocs/op (per-iteration in RunParallel)

- ConstructPrivateKey: ~1.889 ns/op, 0 B/op, 0 allocs/op

These benchmarks demonstrate large reductions in allocations and substantial latency improvements on the hot path.

## Notes & Rationale

- The dominant allocation source was converting private key bytes into an `ecdsa.PrivateKey` (`crypto.ToECDSA`) which allocates big.Ints and uses the C-backed secp256k1 in some paths. The fast path uses `decred/dcrec/secp256k1/v4` APIs to perform scalar base multiplication and writes X/Y directly into a stack-allocated buffer, then Keccak hashes the uncompressed public key into a reused buffer.
- For safety the implementation includes tests that compare the fast path to the standard library output for multiple keys.
- This optimization keeps correctness while reducing GC pressure and increasing throughput.

## Files changed

- `go/internal/worker/crypto.go` — added `DeriveEthereumAddressFast`, comments and zero-alloc path
- `go/internal/worker/scanner.go` — hot-loop buffer/hasher reuse and replaced derivation call
- `go/internal/worker/crypto_bench_test.go` — added fast-path benchmarks
- `go/internal/worker/crypto_test.go` — added equivalence tests

## Next steps

- Run broader profiling (cpu + heap) in representative hardware and add notes to the SDD.
- Iterate on micro-optimizations (e.g., use architecture-specific assembly if needed) only if justified by profiling.

---

Completed by: automated edit (task runner)
