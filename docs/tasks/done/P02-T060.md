# P02-T060: Create database initialization function (apply schema on first run)

**Phase:** P02 - Database Layer Implementation  
**Status:** In Progress  
**Priority:** High  
**Dependencies:** P02-T050  
**Estimated Effort:** Medium

---

## Description

Implement a database initialization function that automatically applies the SQL schema using the goose migration framework with embedded migration files. This provides a robust migration strategy for the MVP.

---

## Acceptance Criteria

- [x] Create `internal/database/migrate.go` file
- [x] Implement `ApplySchema(ctx context.Context, db *sql.DB) error` function using goose
- [x] Use `//go:embed` to embed migration files in binary
- [x] Add idempotency (safe to run multiple times via goose version tracking)
- [x] Proper error handling with context
- [x] Test on fresh database and existing database

---

## Implementation Notes

```go
package database

import (
	"context"
	"database/sql"
	"embed"
	"fmt"
	"io/fs"

	"github.com/pressly/goose/v3"
)

//go:embed sql/*.sql
var migrations embed.FS

// ApplySchema applies the database schema using goose migrations
// Safe to run multiple times (idempotent via goose version tracking)
func ApplySchema(ctx context.Context, db *sql.DB) error {
	// Create a sub filesystem for the sql directory
	subFS, err := fs.Sub(migrations, "sql")
	if err != nil {
		return fmt.Errorf("failed to create sub filesystem: %w", err)
	}

	// Set goose to use the embedded filesystem for migrations
	goose.SetBaseFS(subFS)

	// Set dialect for SQLite
	if err := goose.SetDialect("sqlite3"); err != nil {
		return fmt.Errorf("failed to set goose dialect: %w", err)
	}

	// Run all up migrations
	return goose.UpContext(ctx, db, subFS)
}

// InitDBWithSchema is a convenience function that opens DB and applies schema
func InitDBWithSchema(ctx context.Context, dbPath string) (*sql.DB, error) {
	db, err := InitDB(dbPath)
	if err != nil {
		return nil, err
	}

	if err := ApplySchema(ctx, db); err != nil {
		db.Close()
		return nil, err
	}

	return db, nil
}
```

**Key Points:**
- Use `//go:embed` to include migration files in compiled binary
- Goose handles version tracking via `goose_db_version` table
- Idempotent via goose's version checking
- Proper error handling with context wrapping

---

## Testing

Create a test file `internal/database/migrate_test.go`:

```go
package database

import (
    "context"
    "os"
    "testing"
)

func TestApplySchema(t *testing.T) {
    // Create temporary database
    dbPath := "test_schema.db"
    defer os.Remove(dbPath)
    
    ctx := context.Background()
    
    // Initialize database with schema
    db, err := InitDBWithSchema(ctx, dbPath)
    if err != nil {
        t.Fatalf("Failed to initialize database: %v", err)
    }
    defer db.Close()
    
    // Verify tables exist
    var count int
    err = db.QueryRowContext(ctx, 
        "SELECT COUNT(*) FROM sqlite_master WHERE type='table'",
    ).Scan(&count)
    
    if err != nil {
        t.Fatalf("Failed to query tables: %v", err)
    }
    
    if count < 3 {
        t.Errorf("Expected at least 3 tables, got %d", count)
    }
    
    // Run again (idempotency test)
    err = ApplySchema(ctx, db)
    if err != nil {
        t.Errorf("Schema apply should be idempotent: %v", err)
    }
}
```

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4.1: Schema)
- Schema file: `internal/database/sql/001_schema.sql`
- Go embed directive: https://pkg.go.dev/embed
- Related tasks: P02-T050, P02-T070
