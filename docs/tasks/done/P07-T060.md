# P07-T060: Implement save_checkpoint() using nvs_set_blob for atomic job persistence

**Phase:** P07 - ESP32 Worker - Core Infrastructure  
**Status:** Not Started  
**Priority:** High  
**Dependencies:** P07-T050  
**Estimated Effort:** Medium

---

## Description

Implement `save_checkpoint()` function using `nvs_set_blob()` to atomically persist current job state (prefix, nonce range, current progress) to NVS. This ensures recovery capability after power loss or crash.

## Acceptance Criteria

- [x] `save_checkpoint()` function implemented
- [x] Job state structure defined (`job_checkpoint_t`)
- [x] Uses `nvs_set_blob()` for atomic write
- [x] `nvs_commit()` called after write to ensure flush
- [x] Error handling for NVS write failures
- [x] Checkpoint includes: job_id, prefix_28, nonce_start, nonce_end, current_nonce, keys_scanned

## Implementation Notes

**File:** `esp32/src/nvs_handler.c`

**Checkpoint structure:**
```c
// esp32/include/shared_types.h
#define PREFIX_28_SIZE 28

typedef struct {
    int64_t job_id;
    uint8_t prefix_28[PREFIX_28_SIZE];
    uint64_t nonce_start;
    uint64_t nonce_end;
    uint64_t current_nonce;
    uint64_t keys_scanned;
    uint64_t timestamp;  // For staleness detection
    uint32_t magic;      // 0xDEADBEEF for validity check
} job_checkpoint_t;
```

**Implementation:**
```c
#include "nvs.h"
#include "esp_log.h"

#define NVS_CHECKPOINT_KEY "job_ckpt"
#define CHECKPOINT_MAGIC 0xDEADBEEF

esp_err_t save_checkpoint(nvs_handle_t handle, const job_checkpoint_t* checkpoint)
{
    if (checkpoint == NULL) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Set magic number for validity check
    job_checkpoint_t ckpt_copy = *checkpoint;
    ckpt_copy.magic = CHECKPOINT_MAGIC;
    ckpt_copy.timestamp = esp_timer_get_time() / 1000000ULL; // seconds since boot
    
    // Write blob atomically
    esp_err_t err = nvs_set_blob(handle, NVS_CHECKPOINT_KEY, 
                                 &ckpt_copy, sizeof(job_checkpoint_t));
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to write checkpoint: %s", esp_err_to_name(err));
        return err;
    }
    
    // Commit to ensure data is written to flash
    err = nvs_commit(handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to commit checkpoint: %s", esp_err_to_name(err));
        return err;
    }
    
    ESP_LOGI(TAG, "Checkpoint saved: job_id=%lld, current_nonce=%llu", 
             ckpt_copy.job_id, ckpt_copy.current_nonce);
    
    return ESP_OK;
}
```

**Usage pattern:**
```c
// In worker loop or periodic checkpoint task
job_checkpoint_t checkpoint = {
    .job_id = g_state.current_job.id,
    .nonce_start = g_state.current_job.nonce_start,
    .nonce_end = g_state.current_job.nonce_end,
    .current_nonce = atomic_load(&g_state.current_nonce),
    .keys_scanned = atomic_load(&g_state.keys_scanned),
};
memcpy(checkpoint.prefix_28, g_state.current_job.prefix_28, PREFIX_28_SIZE);

esp_err_t err = save_checkpoint(g_state.nvs_handle, &checkpoint);
if (err != ESP_OK) {
    ESP_LOGW(TAG, "Checkpoint save failed, continuing...");
}
```

**Write frequency:**
- Every 60 seconds (background timer task)
- Before submitting API checkpoint
- Before completing job
- On critical state changes

**NVS wear leveling:**
- NVS handles wear leveling automatically
- ~100,000 write cycles per sector
- At 60-second intervals: ~69 days per sector cycle

## Testing

- Call `save_checkpoint()` with test data
- Verify NVS entry created with `nvs_get_blob()`
- Verify checkpoint contains correct magic number
- Test error handling when NVS is full
- Power cycle ESP32 and verify data persists

## References

- SDD: `docs/architecture/system-design-document.md` (Checkpoint Recovery)
- ESP-IDF NVS Blobs: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/nvs_flash.html#blobs
- Related tasks: P07-T070 (load_checkpoint will read this data)
