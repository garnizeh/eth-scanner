# P02-T080: Write unit tests for database layer

**Phase:** P02 - Database Layer Implementation  
**Status:** Completed  
**Priority:** Medium  
**Dependencies:** P02-T060  
**Estimated Effort:** Medium

---

## Description

Create comprehensive unit tests for the database layer including:
- Database connection and initialization
- Schema application
- sqlc-generated query functions (basic smoke tests)
- Edge cases and error handling
- UTC timestamp handling

These tests ensure the database layer works correctly with `modernc.org/sqlite` and validates the sqlc-generated code.

---

## Acceptance Criteria

- [x] Create `internal/database/connection_test.go`
- [x] Create `internal/database/queries_test.go`
- [x] Test database initialization (InitDB)
- [x] Test schema application (migration runs automatically in InitDB)
- [x] Test basic CRUD operations using sqlc queries
- [x] Test lease allocation logic (FindAvailableBatch, CreateBatch)
- [x] Test checkpoint updates (UpdateCheckpoint)
- [x] Test batch completion (CompleteBatch)
- [x] Test UTC timestamp handling (no time.Local)
- [x] Test concurrent access (if applicable)
- [x] All tests pass with `make test`
- [x] Add test coverage target to Makefile

---

## Implementation Notes

### Test Structure

**File: `internal/database/connection_test.go`**
```go
package database

import (
    "context"
    "os"
    "testing"
)

func TestInitDB(t *testing.T) {
    dbPath := "test_init.db"
    defer os.Remove(dbPath)
    
    db, err := InitDB(dbPath)
    if err != nil {
        t.Fatalf("InitDB failed: %v", err)
    }
    defer db.Close()
    
    // Test ping
    if err := db.Ping(); err != nil {
        t.Errorf("Database ping failed: %v", err)
    }
}

func TestInitDBWithSchema(t *testing.T) {
    ctx := context.Background()
    dbPath := "test_schema.db"
    defer os.Remove(dbPath)
    
    db, err := InitDBWithSchema(ctx, dbPath)
    if err != nil {
        t.Fatalf("InitDBWithSchema failed: %v", err)
    }
    defer db.Close()
    
    // Verify tables exist
    queries := NewQueries(db)
    
    // Try to query stats (should not error even with empty tables)
    _, err = queries.GetStats(ctx)
    if err != nil {
        t.Errorf("GetStats failed on fresh database: %v", err)
    }
}
```

**File: `internal/database/queries_test.go`**
```go
package database

import (
    "context"
    "os"
    "testing"
    "time"
)

func setupTestDB(t *testing.T) (*sql.DB, *Queries) {
    ctx := context.Background()
    dbPath := "test_queries.db"
    t.Cleanup(func() { os.Remove(dbPath) })
    
    db, err := InitDBWithSchema(ctx, dbPath)
    if err != nil {
        t.Fatalf("Failed to setup test database: %v", err)
    }
    
    return db, NewQueries(db)
}

func TestCreateAndLeaseBatch(t *testing.T) {
    ctx := context.Background()
    db, queries := setupTestDB(t)
    defer db.Close()
    
    // Create a batch
    prefix := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28}
    
    job, err := queries.CreateBatch(ctx, CreateBatchParams{
        Prefix28:           prefix,
        NonceStart:         0,
        NonceEnd:           1000000,
        CurrentNonce:       sql.NullInt64{Valid: false},
        WorkerID:           sql.NullString{String: "test-worker-1", Valid: true},
        WorkerType:         sql.NullString{String: "pc", Valid: true},
        RequestedBatchSize: sql.NullInt64{Int64: 1000000, Valid: true},
        ExpiresAt:          3600, // 1 hour in seconds (for SQL param)
    })
    
    if err != nil {
        t.Fatalf("CreateBatch failed: %v", err)
    }
    
    if job.Status != "processing" {
        t.Errorf("Expected status 'processing', got '%s'", job.Status)
    }
    
    if !job.WorkerID.Valid || job.WorkerID.String != "test-worker-1" {
        t.Errorf("Worker ID not set correctly")
    }
    
    // Verify expires_at is in the future
    if !job.ExpiresAt.Valid {
        t.Error("ExpiresAt should be set")
    }
}

func TestFindAvailableBatch(t *testing.T) {
    ctx := context.Background()
    db, queries := setupTestDB(t)
    defer db.Close()
    
    prefix := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28}
    
    // Create a pending job (insert directly with status=pending)
    _, err := db.ExecContext(ctx, `
        INSERT INTO jobs (prefix_28, nonce_start, nonce_end, status)
        VALUES (?, ?, ?, 'pending')
    `, prefix, 0, 1000000)
    
    if err != nil {
        t.Fatalf("Failed to insert test job: %v", err)
    }
    
    // Find available batch
    job, err := queries.FindAvailableBatch(ctx)
    if err != nil {
        t.Fatalf("FindAvailableBatch failed: %v", err)
    }
    
    if job.Status != "pending" {
        t.Errorf("Expected pending job, got %s", job.Status)
    }
}

func TestUpdateCheckpoint(t *testing.T) {
    ctx := context.Background()
    db, queries := setupTestDB(t)
    defer db.Close()
    
    prefix := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28}
    
    // Create a processing job
    job, err := queries.CreateBatch(ctx, CreateBatchParams{
        Prefix28:           prefix,
        NonceStart:         0,
        NonceEnd:           1000000,
        CurrentNonce:       sql.NullInt64{Valid: false},
        WorkerID:           sql.NullString{String: "test-worker-1", Valid: true},
        WorkerType:         sql.NullString{String: "pc", Valid: true},
        RequestedBatchSize: sql.NullInt64{Int64: 1000000, Valid: true},
        ExpiresAt:          3600,
    })
    
    if err != nil {
        t.Fatalf("CreateBatch failed: %v", err)
    }
    
    // Update checkpoint
    err = queries.UpdateCheckpoint(ctx, UpdateCheckpointParams{
        CurrentNonce: sql.NullInt64{Int64: 500000, Valid: true},
        KeysScanned:  sql.NullInt64{Int64: 500000, Valid: true},
        ID:           job.ID,
        WorkerID:     sql.NullString{String: "test-worker-1", Valid: true},
    })
    
    if err != nil {
        t.Errorf("UpdateCheckpoint failed: %v", err)
    }
    
    // Verify update
    updated, err := queries.GetJobByID(ctx, job.ID)
    if err != nil {
        t.Fatalf("GetJobByID failed: %v", err)
    }
    
    if !updated.CurrentNonce.Valid || updated.CurrentNonce.Int64 != 500000 {
        t.Errorf("CurrentNonce not updated correctly")
    }
    
    if !updated.KeysScanned.Valid || updated.KeysScanned.Int64 != 500000 {
        t.Errorf("KeysScanned not updated correctly")
    }
}

func TestCompleteBatch(t *testing.T) {
    ctx := context.Background()
    db, queries := setupTestDB(t)
    defer db.Close()
    
    prefix := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28}
    
    // Create a processing job
    job, err := queries.CreateBatch(ctx, CreateBatchParams{
        Prefix28:           prefix,
        NonceStart:         0,
        NonceEnd:           1000000,
        CurrentNonce:       sql.NullInt64{Valid: false},
        WorkerID:           sql.NullString{String: "test-worker-1", Valid: true},
        WorkerType:         sql.NullString{String: "pc", Valid: true},
        RequestedBatchSize: sql.NullInt64{Int64: 1000000, Valid: true},
        ExpiresAt:          3600,
    })
    
    if err != nil {
        t.Fatalf("CreateBatch failed: %v", err)
    }
    
    // Complete batch
    err = queries.CompleteBatch(ctx, CompleteBatchParams{
        KeysScanned: sql.NullInt64{Int64: 1000000, Valid: true},
        ID:          job.ID,
        WorkerID:    sql.NullString{String: "test-worker-1", Valid: true},
    })
    
    if err != nil {
        t.Errorf("CompleteBatch failed: %v", err)
    }
    
    // Verify completion
    completed, err := queries.GetJobByID(ctx, job.ID)
    if err != nil {
        t.Fatalf("GetJobByID failed: %v", err)
    }
    
    if completed.Status != "completed" {
        t.Errorf("Expected status 'completed', got '%s'", completed.Status)
    }
    
    if !completed.CompletedAt.Valid {
        t.Error("CompletedAt should be set")
    }
}

func TestUTCTimestamps(t *testing.T) {
    ctx := context.Background()
    db, queries := setupTestDB(t)
    defer db.Close()
    
    prefix := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28}
    
    // Create job
    job, err := queries.CreateBatch(ctx, CreateBatchParams{
        Prefix28:           prefix,
        NonceStart:         0,
        NonceEnd:           1000000,
        CurrentNonce:       sql.NullInt64{Valid: false},
        WorkerID:           sql.NullString{String: "test-worker-1", Valid: true},
        WorkerType:         sql.NullString{String: "pc", Valid: true},
        RequestedBatchSize: sql.NullInt64{Int64: 1000000, Valid: true},
        ExpiresAt:          3600,
    })
    
    if err != nil {
        t.Fatalf("CreateBatch failed: %v", err)
    }
    
    // Verify created_at is UTC
    if job.CreatedAt.Location() != time.UTC {
        t.Errorf("CreatedAt should be UTC, got %s", job.CreatedAt.Location())
    }
    
    // Verify expires_at is UTC
    if job.ExpiresAt.Valid && job.ExpiresAt.Time.Location() != time.UTC {
        t.Errorf("ExpiresAt should be UTC, got %s", job.ExpiresAt.Time.Location())
    }
}
```

---

## Testing Checklist

- [x] Connection tests run successfully
- [x] Schema initialization tests pass
- [x] CRUD operations work correctly
- [x] Lease logic tested (pending â†’ processing)
- [x] Checkpoint logic tested
- [x] Completion logic tested
- [x] UTC timestamps verified
- [x] Edge cases handled (expired leases, invalid worker IDs)
- [x] Tests run with `make test`
- [x] Coverage report generated with `make test-coverage`

---

## References

- SDD: `docs/architecture/system-design-document.md` (Section 4: Database)
- Go testing: https://pkg.go.dev/testing
- Related tasks: P02-T050, P02-T060
